# Simulation Results – AXI Stereo Delay

This document summarizes the simulation results of the **delay_core** and
**delay_axis** modules based on CSV data generated by their respective
testbenches:

- `tb_data_delay_core.csv`
- `tb_data_delay_axis.csv`

The simulations were conducted to verify:
1. Correct operation of a BRAM-based circular delay line
2. Behavior under static and dynamic (modulated) delay conditions
3. Proper integration of the delay engine into an AXI4-Stream and AXI4-Lite
   based system

---

## 1. Results: `delay_axis` (AXI4-Stream Stereo Delay)

### 1.1 Test Configuration
- Clock frequency: 100 MHz
- Audio data width: 16-bit signed
- Stereo AXI4-Stream (Left & Right packed into 32-bit words)
- Delay registers:
  - Left channel delay: 50 samples
  - Right channel delay: 100 samples
- Input signals:
  - Left channel: sine wave, period = 50 samples
  - Right channel: sine wave, period = 100 samples
- AXI-Stream backpressure: disabled (`m_axis_tready = 1`)

---

### 1.2 Observations

#### a. Input–Output Alignment
- `Out_L` and `Out_R` are delayed replicas of `In_L` and `In_R`
- No observable:
  - amplitude distortion
  - clipping
  - waveform deformation

This confirms that the delay operation is a **pure time shift** with no
additional arithmetic processing in the data path.

---

#### b. Independent Stereo Delays
- The left channel output appears earlier than the right channel output
- The observed time offset matches the programmed delay values

This demonstrates that:
> **Each stereo channel is delayed independently, with no crosstalk.**

---

#### c. AXI Stream Valid Signal
- `m_axis_tvalid` asserts steadily once the internal pipeline is filled
- No glitches or unexpected deassertions are observed during streaming

This indicates that:
- Stream control logic is correct
- Internal latency (1-cycle BRAM read) is properly compensated by control
  signal alignment

---

### 1.3 Conclusion for `delay_axis`

- The `delay_axis` module functions correctly as a stereo AXI4-Stream delay
- AXI handshaking and synchronization are stable
- The module is suitable as a reusable AXI-based audio delay IP

---

## 2. Results: `delay_core` (Standalone Delay Engine)

### 2.1 Test Configuration
- Base delay: 50 samples
- Modulation input (`mod_val`): dynamically varied
- Input signal: impulse followed by sine wave
- Tested modes:
  - Static delay
  - Dynamic delay modulation
  - Saturation / boundary conditions
  - Bypass mode

---

### 2.2 Observations

#### a. Static Delay Verification
- An impulse applied at the input appears at the output after the expected
  number of samples
- No undefined or random data is observed at startup

This confirms correct operation of:
- the circular buffer
- read/write pointer management
- memory initialization

---

#### b. Dynamic Delay Modulation
- As `mod_val` changes, the output signal shifts in time accordingly
- No simulation crashes or illegal memory accesses are observed

Phase variation becomes noticeable during rapid delay changes. This behavior
is **expected**, since:
- the design uses integer-sample delays only
- no fractional delay interpolation is implemented

---

#### c. Saturation and Boundary Handling
- When `base_delay + mod_val` becomes negative, the effective delay is clamped
  to a minimum safe value
- When the requested delay exceeds the buffer size, it is clamped to the
  maximum allowable value

This demonstrates that the **safety clamp logic** prevents invalid memory
access.

---

#### d. Bypass Mode
- When `bypass = 1`, the output follows the input directly
- The delay buffer is effectively removed from the signal path

Bypass operation is deterministic and glitch-free.

---

### 2.3 Conclusion for `delay_core`

- `delay_core` operates reliably for both static and dynamic delay scenarios
- The design is robust against extreme or invalid control inputs
- It is suitable as a foundational delay block for FPGA-based audio systems

---

## 3. Design Notes

- The design does **not** implement fractional delay interpolation
- It is **not** intended for high-fidelity chorus or flanger effects
- Primary design goals:
  - deterministic behavior
  - stability
  - straightforward AXI integration

For static delay use cases, audio integrity is well preserved.
Artifacts observed during fast modulation are an acknowledged and accepted
design trade-off.

---

## 4. Overall Conclusion

Based on the simulation data:
- All modules behave according to specification
- No functional bugs were identified in:
  - delay logic
  - AXI handshaking
  - reset and enable behavior
- The design is suitable for:
  - educational purposes
  - FPGA-based audio DSP research
  - use as a baseline reference implementation
